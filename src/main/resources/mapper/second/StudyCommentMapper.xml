<!-- src/main/resources/mapper/Second/StudyCommentMapper.xml -->
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.med.mapper.StudyCommentMapper">

    <select id="findCommentsByStudyKey" resultType="com.example.med.dto.StudyCommentDto">
        SELECT
            comment_id      as commentId,
            study_key       as studyKey,
            user_id         as userId,
            comment_title   as commentTitle,
            comment_content as commentContent,
            created_at      as createdAt,
            updated_at      as updatedAt
        FROM STUDY_COMMENT
        WHERE study_key = #{studyKey}
        ORDER BY created_at DESC
    </select>


    <insert id="insertComment" parameterType="com.example.med.dto.StudyCommentDto" statementType="CALLABLE">
        <!-- Oracle의 RETURNING 절을 사용하여 INSERT 후 생성된 ID를 DTO에 다시 설정합니다. -->
        <!-- 이 방식은 DB 트리거 등에 의해 ID가 자동 생성될 때 유용합니다. -->
        BEGIN
            INSERT INTO study_comment (study_key, user_id, comment_title, comment_content, created_at)
            VALUES (#{studyKey}, #{userId}, #{commentTitle}, #{commentContent}, #{createdAt, jdbcType=TIMESTAMP})
            RETURNING comment_id INTO #{commentId, mode=OUT, jdbcType=BIGINT};
        END;
    </insert>

    <select id="findCommentById" resultType="com.example.med.dto.StudyCommentDto">
        SELECT
            comment_id      as commentId,
            study_key       as studyKey,
            user_id         as userId,
            comment_title   as commentTitle,
            comment_content as commentContent,
            created_at      as createdAt,
            updated_at      as updatedAt
        FROM STUDY_COMMENT
        WHERE comment_id = #{commentId}
    </select>

    <update id="updateComment" parameterType="com.example.med.dto.StudyCommentDto">
        UPDATE STUDY_COMMENT
        SET
            comment_title   = #{commentTitle},
            comment_content = #{commentContent},
            updated_at      = SYSTIMESTAMP
        WHERE comment_id = #{commentId}
    </update>

    <delete id="deleteComment">
        DELETE FROM STUDY_COMMENT
        WHERE comment_id = #{commentId}
    </delete>

    <!--로그 찍기 -->
    <resultMap id="CommentUpdateDto" type="com.example.med.dto.logDto.CommentUpdateLogDto">
        <id     property="logId"          column="LOG_ID"/>
        <result property="studyKey"       column="STUDY_KEY"/>
        <result property="userId"         column="USER_ID"/>
        <result property="commentId"      column="COMMENT_ID"/>
        <result property="commentType"    column="COMMENT_TYPE"/>
        <result property="originalTitle"  column="ORIGINAL_TITLE"/>
        <result property="originalContent" column="ORIGINAL_CONTENT"/>
        <result property="newTitle"       column="NEW_TITLE"/>
        <result property="newContent"     column="NEW_CONTENT"/>
        <result property="actionType"     column="ACTION_TYPE"/>
        <result property="createdAt"      column="CREATED_AT"/>
        <result property="updatedAt"      column="UPDATED_AT"/>
    </resultMap>

    <insert id="updateLog"
            parameterType="com.example.med.dto.logDto.CommentUpdateLogDto">
        INSERT INTO STUDY_COMMENT_LOG (
        STUDY_KEY, USER_ID, COMMENT_ID, COMMENT_TYPE,
        ORIGINAL_TITLE, ORIGINAL_CONTENT, NEW_TITLE, NEW_CONTENT,
        ACTION_TYPE, CREATED_AT
        ) VALUES (
        #{studyKey,        jdbcType=NUMERIC},
        #{userId,          jdbcType=VARCHAR},
        #{commentId,       jdbcType=NUMERIC},
        'COMMENT',                                  <!-- 필요시 동적으로 바꾸면 아래 두 번째 INSERT 참고 -->
        #{originalTitle,   jdbcType=VARCHAR},
        #{originalContent, jdbcType=VARCHAR},
        #{commentTitle,    jdbcType=VARCHAR},
        #{commentContent,  jdbcType=CLOB},
        'U',                                        <!-- 생성=C, 수정=U, 삭제=D 등 -->
        NVL(#{createdAt,  jdbcType=VARCHAR},
        TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS'))
        )
    </insert>

    <insert id="deleteLog"
            parameterType="com.example.med.dto.logDto.CommentDeleteLogDto">
        INSERT INTO STUDY_COMMENT_LOG (
        STUDY_KEY, USER_ID, COMMENT_ID, COMMENT_TYPE,
        ORIGINAL_TITLE, ORIGINAL_CONTENT, NEW_TITLE, NEW_CONTENT,
        ACTION_TYPE, CREATED_AT
        ) VALUES (
        #{studyKey,    jdbcType=NUMERIC},
        #{userId,      jdbcType=VARCHAR},
        #{commentId,   jdbcType=NUMERIC},
        'COMMENT',
        NULLIF(#{originalTitle,   jdbcType=VARCHAR}, ''),
        NULLIF(#{originalContent, jdbcType=VARCHAR}, ''),
        NULL,   -- 삭제 로그라면 new_*는 보통 NULL
        NULL,
        'D',
        NVL(NULLIF(#{createdAt, jdbcType=VARCHAR}, ''),
        TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS'))
        )
    </insert>

    <!-- 생성 로그: DTO에 createdAt이 세팅돼 있으면 그걸 포맷, 없으면 현재시각 포맷 -->
    <insert id="insertLog" parameterType="com.example.med.dto.StudyCommentDto">
        INSERT INTO STUDY_COMMENT_LOG (
            STUDY_KEY, USER_ID, COMMENT_ID, COMMENT_TYPE,
            ORIGINAL_TITLE, ORIGINAL_CONTENT, NEW_TITLE, NEW_CONTENT,
            ACTION_TYPE, CREATED_AT
        ) VALUES (
            #{studyKey,        jdbcType=NUMERIC},
            #{userId,          jdbcType=VARCHAR},
            #{commentId,       jdbcType=NUMERIC},
            'COMMENT',
            NULL, -- 생성 시에는 원본 값이 없음
            NULL, -- 생성 시에는 원본 값이 없음
            #{commentTitle,    jdbcType=VARCHAR},
            #{commentContent,  jdbcType=CLOB},
            'C', -- 생성(Create)
            #{createdAt,       jdbcType=TIMESTAMP}
        )
    </insert>
</mapper>
